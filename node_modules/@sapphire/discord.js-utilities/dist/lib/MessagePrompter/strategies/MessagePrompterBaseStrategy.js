"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessagePrompterBaseStrategy = void 0;
const utilities_1 = require("@sapphire/utilities");
const type_guards_1 = require("../../type-guards");
class MessagePrompterBaseStrategy {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(type, message, options) {
        /**
         * The type of strategy that was used
         */
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The timeout that was used in the collector
         */
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Whether to return an explicit object with data, or the strategies' default
         */
        Object.defineProperty(this, "explicitReturn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The message that has been sent in {@link MessagePrompter.run}
         */
        Object.defineProperty(this, "appliedMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        /**
         * The message that will be sent in {@link MessagePrompter.run}
         */
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The message the bot will edit to send its prompt in {@link MessagePrompter.run}
         */
        Object.defineProperty(this, "editMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.type = type;
        this.timeout = options?.timeout ?? MessagePrompterBaseStrategy.defaultStrategyOptions.timeout ?? 10 * 1000;
        this.explicitReturn = options?.explicitReturn ?? MessagePrompterBaseStrategy.defaultStrategyOptions.explicitReturn ?? false;
        this.editMessage = options?.editMessage ?? MessagePrompterBaseStrategy.defaultStrategyOptions.editMessage ?? undefined;
        this.message = message;
    }
    async collectReactions(channel, authorOrFilter, reactions) {
        if ((0, type_guards_1.isTextBasedChannel)(channel) && !(0, type_guards_1.isStageChannel)(channel)) {
            if (!(0, utilities_1.isNullish)(this.editMessage) && this.editMessage.editable) {
                this.appliedMessage = await this.editMessage.edit(this.message);
            }
            else {
                this.appliedMessage = await channel.send(this.message);
            }
            const collector = this.appliedMessage.createReactionCollector({
                ...this.createReactionPromptFilter(reactions, authorOrFilter),
                max: 1,
                time: this.timeout
            });
            let resolved = false;
            const collected = new Promise((resolve, reject) => {
                collector.on('collect', (r) => {
                    resolve(r);
                    resolved = true;
                    collector.stop();
                });
                collector.on('end', (collected) => {
                    resolved = true;
                    if (!collected.size)
                        reject(new Error('Collector has ended'));
                });
            });
            for (const reaction of reactions) {
                if (resolved)
                    break;
                await this.appliedMessage.react(reaction);
            }
            const firstReaction = await collected;
            const emoji = firstReaction?.emoji;
            const reaction = reactions.find((r) => (emoji?.id ?? emoji?.name) === r);
            return {
                emoji,
                reaction,
                strategy: this,
                appliedMessage: this.appliedMessage,
                message: this.message
            };
        }
        throw new Error('A channel was provided to which I am not able to send messages');
    }
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitReactions function
     */
    createReactionPromptFilter(reactions, authorOrFilter) {
        return {
            filter: async (reaction, user) => reactions.includes(reaction.emoji.id ?? reaction.emoji.name ?? '') &&
                (typeof authorOrFilter === 'function' ? await authorOrFilter(reaction, user) : user.id === authorOrFilter.id) &&
                !user.bot
        };
    }
}
exports.MessagePrompterBaseStrategy = MessagePrompterBaseStrategy;
/**
 * The default strategy options
 */
Object.defineProperty(MessagePrompterBaseStrategy, "defaultStrategyOptions", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        timeout: 10 * 1000,
        explicitReturn: false,
        editMessage: undefined
    }
});
//# sourceMappingURL=MessagePrompterBaseStrategy.js.map