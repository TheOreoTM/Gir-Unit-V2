"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessagePrompterMessageStrategy = void 0;
const utilities_1 = require("@sapphire/utilities");
const type_guards_1 = require("../../type-guards");
const MessagePrompterBaseStrategy_1 = require("./MessagePrompterBaseStrategy");
class MessagePrompterMessageStrategy extends MessagePrompterBaseStrategy_1.MessagePrompterBaseStrategy {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message, options) {
        super('message', message, options);
    }
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals message.
     * The handler will wait for one (1) message.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to the message object received.
     */
    async run(channel, authorOrFilter) {
        if ((0, type_guards_1.isTextBasedChannel)(channel) && !(0, type_guards_1.isStageChannel)(channel)) {
            if (!(0, utilities_1.isNullish)(this.editMessage) && this.editMessage.editable) {
                this.appliedMessage = await this.editMessage.edit(this.message);
            }
            else {
                this.appliedMessage = await channel.send(this.message);
            }
            const collector = await channel.awaitMessages({
                ...this.createMessagePromptFilter(authorOrFilter),
                max: 1,
                time: this.timeout,
                errors: ['time']
            });
            const response = collector.first();
            if (!response) {
                throw new Error('No messages received');
            }
            return this.explicitReturn
                ? {
                    response,
                    strategy: this,
                    appliedMessage: this.appliedMessage,
                    message: this.message
                }
                : response;
        }
        throw new Error('A channel was provided to which I am not able to send messages');
    }
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitMessages function
     */
    createMessagePromptFilter(authorOrFilter) {
        return {
            filter: async (message) => (typeof authorOrFilter === 'function' ? await authorOrFilter(message) : message.author.id === authorOrFilter.id) &&
                !message.author.bot
        };
    }
}
exports.MessagePrompterMessageStrategy = MessagePrompterMessageStrategy;
//# sourceMappingURL=MessagePrompterMessageStrategy.js.map