'use strict';

var lexure = require('@sapphire/lexure');
var pieces = require('@sapphire/pieces');
var utilities = require('@sapphire/utilities');
var discord_js = require('discord.js');
var Args_js = require('../parsers/Args.js');
var Enums_js = require('../types/Enums.js');
var ApplicationCommandRegistries_js = require('../utils/application-commands/ApplicationCommandRegistries.js');
var emitRegistryError_js = require('../utils/application-commands/emitRegistryError.js');
var getNeededParameters_js = require('../utils/application-commands/getNeededParameters.js');
var PreconditionContainerArray_js = require('../utils/preconditions/PreconditionContainerArray.js');
var FlagUnorderedStrategy_js = require('../utils/strategies/FlagUnorderedStrategy.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var Command = class extends pieces.AliasPiece {
  /**
   * @since 1.0.0
   * @param context The context.
   * @param options Optional Command settings.
   */
  constructor(context, options = {}) {
    super(context, { ...options, name: (options.name ?? context.name).toLowerCase() });
    /**
     * The application command registry associated with this command.
     * @since 3.0.0
     */
    this.applicationCommandRegistry = ApplicationCommandRegistries_js.acquire(this.name);
    this.description = options.description ?? "";
    this.detailedDescription = options.detailedDescription ?? "";
    this.strategy = new FlagUnorderedStrategy_js.FlagUnorderedStrategy(options);
    this.fullCategory = options.fullCategory ?? this.location.directories;
    this.typing = options.typing ?? true;
    this.lexer = new lexure.Lexer({
      quotes: options.quotes ?? [
        ['"', '"'],
        // Double quotes
        ["\u201C", "\u201D"],
        // Fancy quotes (on iOS)
        ["\u300C", "\u300D"],
        // Corner brackets (CJK)
        ["\xAB", "\xBB"]
        // French quotes (guillemets)
      ]
    });
    if (options.generateDashLessAliases) {
      const dashLessAliases = [];
      if (this.name.includes("-"))
        dashLessAliases.push(this.name.replace(/-/g, ""));
      for (const alias of this.aliases)
        if (alias.includes("-"))
          dashLessAliases.push(alias.replace(/-/g, ""));
      this.aliases = [...this.aliases, ...dashLessAliases];
    }
    if (options.generateUnderscoreLessAliases) {
      const underscoreLessAliases = [];
      if (this.name.includes("_"))
        underscoreLessAliases.push(this.name.replace(/_/g, ""));
      for (const alias of this.aliases)
        if (alias.includes("_"))
          underscoreLessAliases.push(alias.replace(/_/g, ""));
      this.aliases = [...this.aliases, ...underscoreLessAliases];
    }
    this.preconditions = new PreconditionContainerArray_js.PreconditionContainerArray(options.preconditions);
    this.parseConstructorPreConditions(options);
  }
  /**
   * The message pre-parse method. This method can be overridden by plugins to define their own argument parser.
   * @param message The message that triggered the command.
   * @param parameters The raw parameters as a single string.
   * @param context The command-context used in this execution.
   */
  messagePreParse(message, parameters, context) {
    const parser = new lexure.Parser(this.strategy);
    const args = new lexure.ArgumentStream(parser.run(this.lexer.run(parameters)));
    return new Args_js.Args(message, this, args, context);
  }
  /**
   * The main category for the command, if any.
   *
   * This getter retrieves the first value of {@link Command.fullCategory}, if it has at least one item, otherwise it
   * returns `null`.
   *
   * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
   */
  get category() {
    return this.fullCategory.length > 0 ? this.fullCategory[0] : null;
  }
  /**
   * The sub-category for the command, if any.
   *
   * This getter retrieves the second value of {@link Command.fullCategory}, if it has at least two items, otherwise
   * it returns `null`.
   *
   * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
   */
  get subCategory() {
    return this.fullCategory.length > 1 ? this.fullCategory[1] : null;
  }
  /**
   * The parent category for the command.
   *
   * This getter retrieves the last value of {@link Command.fullCategory}, if it has at least one item, otherwise it
   * returns `null`.
   *
   * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
   */
  get parentCategory() {
    return this.fullCategory.length > 1 ? this.fullCategory[this.fullCategory.length - 1] : null;
  }
  /**
   * Defines the JSON.stringify behavior of the command.
   */
  toJSON() {
    return {
      ...super.toJSON(),
      description: this.description,
      detailedDescription: this.detailedDescription,
      category: this.category
    };
  }
  /**
   * Type-guard that ensures the command supports message commands by checking if the handler for it is present
   */
  supportsMessageCommands() {
    return Reflect.has(this, "messageRun");
  }
  /**
   * Type-guard that ensures the command supports chat input commands by checking if the handler for it is present
   */
  supportsChatInputCommands() {
    return Reflect.has(this, "chatInputRun");
  }
  /**
   * Type-guard that ensures the command supports context menu commands by checking if the handler for it is present
   */
  supportsContextMenuCommands() {
    return Reflect.has(this, "contextMenuRun");
  }
  /**
   * Type-guard that ensures the command supports handling autocomplete interactions by checking if the handler for it is present
   */
  supportsAutocompleteInteractions() {
    return Reflect.has(this, "autocompleteRun");
  }
  async reload() {
    const { store } = this;
    const registry = this.applicationCommandRegistry;
    for (const nameOrId of registry.chatInputCommands) {
      const aliasedPiece = store.aliases.get(nameOrId);
      if (aliasedPiece === this) {
        store.aliases.delete(nameOrId);
      }
    }
    for (const nameOrId of registry.contextMenuCommands) {
      const aliasedPiece = store.aliases.get(nameOrId);
      if (aliasedPiece === this) {
        store.aliases.delete(nameOrId);
      }
    }
    registry.chatInputCommands.clear();
    registry.contextMenuCommands.clear();
    registry.guildIdsToFetch.clear();
    registry["apiCalls"].length = 0;
    await super.reload();
    const updatedPiece = store.get(this.name);
    if (!updatedPiece)
      return;
    const updatedRegistry = updatedPiece.applicationCommandRegistry;
    if (updatedPiece.registerApplicationCommands) {
      try {
        await updatedPiece.registerApplicationCommands(updatedRegistry);
      } catch (err) {
        emitRegistryError_js.emitRegistryError(err, updatedPiece);
        return;
      }
    }
    if (!updatedRegistry["apiCalls"].length) {
      return;
    }
    if (ApplicationCommandRegistries_js.getDefaultBehaviorWhenNotIdentical() === Enums_js.RegisterBehavior.BulkOverwrite) {
      await ApplicationCommandRegistries_js.handleBulkOverwrite(store, this.container.client.application.commands);
      return;
    }
    const { applicationCommands, globalCommands, guildCommands } = await getNeededParameters_js.getNeededRegistryParameters(updatedRegistry.guildIdsToFetch);
    await updatedRegistry["runAPICalls"](applicationCommands, globalCommands, guildCommands);
    for (const nameOrId of updatedRegistry.chatInputCommands) {
      store.aliases.set(nameOrId, updatedPiece);
    }
    for (const nameOrId of updatedRegistry.contextMenuCommands) {
      store.aliases.set(nameOrId, updatedPiece);
    }
  }
  /**
   * Parses the command's options and processes them, calling {@link Command#parseConstructorPreConditionsRunIn},
   * {@link Command#parseConstructorPreConditionsNsfw},
   * {@link Command#parseConstructorPreConditionsRequiredClientPermissions}, and
   * {@link Command#parseConstructorPreConditionsCooldown}.
   * @since 2.0.0
   * @param options The command options given from the constructor.
   */
  parseConstructorPreConditions(options) {
    this.parseConstructorPreConditionsRunIn(options);
    this.parseConstructorPreConditionsNsfw(options);
    this.parseConstructorPreConditionsRequiredClientPermissions(options);
    this.parseConstructorPreConditionsRequiredUserPermissions(options);
    this.parseConstructorPreConditionsCooldown(options);
  }
  /**
   * Appends the `NSFW` precondition if {@link Command.Options.nsfw} is set to true.
   * @param options The command options given from the constructor.
   */
  parseConstructorPreConditionsNsfw(options) {
    if (options.nsfw)
      this.preconditions.append("NSFW" /* NotSafeForWork */);
  }
  /**
   * Appends the `DMOnly`, `GuildOnly`, `NewsOnly`, and `TextOnly` preconditions based on the values passed in
   * {@link Command.Options.runIn}, optimizing in specific cases (`NewsOnly` + `TextOnly` = `GuildOnly`; `DMOnly` +
   * `GuildOnly` = `null`), defaulting to `null`, which doesn't add a precondition.
   * @param options The command options given from the constructor.
   */
  parseConstructorPreConditionsRunIn(options) {
    const runIn = this.resolveConstructorPreConditionsRunType(options.runIn);
    if (runIn !== null)
      this.preconditions.append(runIn);
  }
  /**
   * Appends the `ClientPermissions` precondition when {@link Command.Options.requiredClientPermissions} resolves to a
   * non-zero bitfield.
   * @param options The command options given from the constructor.
   */
  parseConstructorPreConditionsRequiredClientPermissions(options) {
    const permissions = new discord_js.PermissionsBitField(options.requiredClientPermissions);
    if (permissions.bitfield !== 0n) {
      this.preconditions.append({ name: "ClientPermissions" /* ClientPermissions */, context: { permissions } });
    }
  }
  /**
   * Appends the `UserPermissions` precondition when {@link Command.Options.requiredUserPermissions} resolves to a
   * non-zero bitfield.
   * @param options The command options given from the constructor.
   */
  parseConstructorPreConditionsRequiredUserPermissions(options) {
    const permissions = new discord_js.PermissionsBitField(options.requiredUserPermissions);
    if (permissions.bitfield !== 0n) {
      this.preconditions.append({ name: "UserPermissions" /* UserPermissions */, context: { permissions } });
    }
  }
  /**
   * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and
   * {@link Command.Options.cooldownDelay} are both non-zero.
   * @param options The command options given from the constructor.
   */
  parseConstructorPreConditionsCooldown(options) {
    const { defaultCooldown } = this.container.client.options;
    const filtered = defaultCooldown?.filteredCommands?.includes(this.name) ?? false;
    const limit = options.cooldownLimit ?? (filtered ? 0 : defaultCooldown?.limit ?? 1);
    const delay = options.cooldownDelay ?? (filtered ? 0 : defaultCooldown?.delay ?? 0);
    if (limit && delay) {
      const scope = options.cooldownScope ?? defaultCooldown?.scope ?? Enums_js.BucketScope.User;
      const filteredUsers = options.cooldownFilteredUsers ?? defaultCooldown?.filteredUsers;
      this.preconditions.append({
        name: "Cooldown" /* Cooldown */,
        context: { scope, limit, delay, filteredUsers }
      });
    }
  }
  resolveConstructorPreConditionsRunType(runIn) {
    if (utilities.isNullish(runIn))
      return null;
    if (typeof runIn === "string") {
      switch (runIn) {
        case "DM":
          return "DMOnly" /* DirectMessageOnly */;
        case "GUILD_TEXT":
          return "GuildTextOnly" /* GuildTextOnly */;
        case "GUILD_VOICE":
          return "GuildVoiceOnly" /* GuildVoiceOnly */;
        case "GUILD_NEWS":
          return "GuildNewsOnly" /* GuildNewsOnly */;
        case "GUILD_NEWS_THREAD":
          return "GuildNewsThreadOnly" /* GuildNewsThreadOnly */;
        case "GUILD_PUBLIC_THREAD":
          return "GuildPublicThreadOnly" /* GuildPublicThreadOnly */;
        case "GUILD_PRIVATE_THREAD":
          return "GuildPrivateThreadOnly" /* GuildPrivateThreadOnly */;
        case "GUILD_ANY":
          return "GuildOnly" /* GuildOnly */;
        default:
          return null;
      }
    }
    if (runIn.length === 0) {
      throw new Error(`${this.constructor.name}[${this.name}]: "runIn" was specified as an empty array.`);
    }
    if (runIn.length === 1) {
      return this.resolveConstructorPreConditionsRunType(runIn[0]);
    }
    const keys = new Set(runIn);
    const dm = keys.has("DM");
    const guildText = keys.has("GUILD_TEXT");
    const guildVoice = keys.has("GUILD_VOICE");
    const guildNews = keys.has("GUILD_NEWS");
    const guild = guildText && guildNews && guildVoice;
    if (dm && guild)
      return null;
    const guildPublicThread = keys.has("GUILD_PUBLIC_THREAD");
    const guildPrivateThread = keys.has("GUILD_PRIVATE_THREAD");
    const guildNewsThread = keys.has("GUILD_NEWS_THREAD");
    const guildThreads = guildPublicThread && guildPrivateThread && guildNewsThread;
    if (guildThreads && keys.size === 3) {
      return "GuildThreadOnly" /* GuildThreadOnly */;
    }
    const preconditions = new PreconditionContainerArray_js.PreconditionContainerArray();
    if (dm)
      preconditions.append("DMOnly" /* DirectMessageOnly */);
    if (guild) {
      preconditions.append("GuildOnly" /* GuildOnly */);
    } else {
      if (guildText) {
        preconditions.append("GuildTextOnly" /* GuildTextOnly */);
      } else {
        if (guildPublicThread)
          preconditions.append("GuildPublicThreadOnly" /* GuildPublicThreadOnly */);
        if (guildPrivateThread)
          preconditions.append("GuildPrivateThreadOnly" /* GuildPrivateThreadOnly */);
      }
      if (guildNews) {
        preconditions.append("GuildNewsOnly" /* GuildNewsOnly */);
      } else if (guildNewsThread) {
        preconditions.append("GuildNewsThreadOnly" /* GuildNewsThreadOnly */);
      }
      if (guildVoice) {
        preconditions.append("GuildVoiceOnly" /* GuildVoiceOnly */);
      }
    }
    return preconditions;
  }
};
__name(Command, "Command");
var CommandOptionsRunTypeEnum = /* @__PURE__ */ ((CommandOptionsRunTypeEnum2) => {
  CommandOptionsRunTypeEnum2["Dm"] = "DM";
  CommandOptionsRunTypeEnum2["GuildText"] = "GUILD_TEXT";
  CommandOptionsRunTypeEnum2["GuildVoice"] = "GUILD_VOICE";
  CommandOptionsRunTypeEnum2["GuildNews"] = "GUILD_NEWS";
  CommandOptionsRunTypeEnum2["GuildNewsThread"] = "GUILD_NEWS_THREAD";
  CommandOptionsRunTypeEnum2["GuildPublicThread"] = "GUILD_PUBLIC_THREAD";
  CommandOptionsRunTypeEnum2["GuildPrivateThread"] = "GUILD_PRIVATE_THREAD";
  CommandOptionsRunTypeEnum2["GuildAny"] = "GUILD_ANY";
  return CommandOptionsRunTypeEnum2;
})(CommandOptionsRunTypeEnum || {});
var CommandPreConditions = /* @__PURE__ */ ((CommandPreConditions2) => {
  CommandPreConditions2["Cooldown"] = "Cooldown";
  CommandPreConditions2["DirectMessageOnly"] = "DMOnly";
  CommandPreConditions2["GuildNewsOnly"] = "GuildNewsOnly";
  CommandPreConditions2["GuildNewsThreadOnly"] = "GuildNewsThreadOnly";
  CommandPreConditions2["GuildOnly"] = "GuildOnly";
  CommandPreConditions2["GuildPrivateThreadOnly"] = "GuildPrivateThreadOnly";
  CommandPreConditions2["GuildPublicThreadOnly"] = "GuildPublicThreadOnly";
  CommandPreConditions2["GuildTextOnly"] = "GuildTextOnly";
  CommandPreConditions2["GuildVoiceOnly"] = "GuildVoiceOnly";
  CommandPreConditions2["GuildThreadOnly"] = "GuildThreadOnly";
  CommandPreConditions2["NotSafeForWork"] = "NSFW";
  CommandPreConditions2["ClientPermissions"] = "ClientPermissions";
  CommandPreConditions2["UserPermissions"] = "UserPermissions";
  return CommandPreConditions2;
})(CommandPreConditions || {});

exports.Command = Command;
exports.CommandOptionsRunTypeEnum = CommandOptionsRunTypeEnum;
exports.CommandPreConditions = CommandPreConditions;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=Command.js.map